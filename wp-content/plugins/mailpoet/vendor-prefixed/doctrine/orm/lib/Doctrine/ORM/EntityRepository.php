<?php
 namespace MailPoetVendor\Doctrine\ORM; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\ORM\Query\ResultSetMappingBuilder; use MailPoetVendor\Doctrine\Common\Persistence\ObjectRepository; use MailPoetVendor\Doctrine\Common\Collections\Selectable; use MailPoetVendor\Doctrine\Common\Collections\Criteria; use MailPoetVendor\Doctrine\Common\Collections\ArrayCollection; class EntityRepository implements \MailPoetVendor\Doctrine\Common\Persistence\ObjectRepository, \MailPoetVendor\Doctrine\Common\Collections\Selectable { protected $_entityName; protected $_em; protected $_class; public function __construct($em, \MailPoetVendor\Doctrine\ORM\Mapping\ClassMetadata $class) { $this->_entityName = $class->name; $this->_em = $em; $this->_class = $class; } public function createQueryBuilder($alias, $indexBy = null) { return $this->_em->createQueryBuilder()->select($alias)->from($this->_entityName, $alias, $indexBy); } public function createResultSetMappingBuilder($alias) { $rsm = new \MailPoetVendor\Doctrine\ORM\Query\ResultSetMappingBuilder($this->_em, \MailPoetVendor\Doctrine\ORM\Query\ResultSetMappingBuilder::COLUMN_RENAMING_INCREMENT); $rsm->addRootEntityFromClassMetadata($this->_entityName, $alias); return $rsm; } public function createNamedQuery($queryName) { return $this->_em->createQuery($this->_class->getNamedQuery($queryName)); } public function createNativeNamedQuery($queryName) { $queryMapping = $this->_class->getNamedNativeQuery($queryName); $rsm = new \MailPoetVendor\Doctrine\ORM\Query\ResultSetMappingBuilder($this->_em); $rsm->addNamedNativeQueryMapping($this->_class, $queryMapping); return $this->_em->createNativeQuery($queryMapping['query'], $rsm); } public function clear() { $this->_em->clear($this->_class->rootEntityName); } public function find($id, $lockMode = null, $lockVersion = null) { return $this->_em->find($this->_entityName, $id, $lockMode, $lockVersion); } public function findAll() { return $this->findBy(array()); } public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) { $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName); return $persister->loadAll($criteria, $orderBy, $limit, $offset); } public function findOneBy(array $criteria, array $orderBy = null) { $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName); return $persister->load($criteria, null, null, array(), null, 1, $orderBy); } public function __call($method, $arguments) { switch (\true) { case 0 === \strpos($method, 'findBy'): $by = \substr($method, 6); $method = 'findBy'; break; case 0 === \strpos($method, 'findOneBy'): $by = \substr($method, 9); $method = 'findOneBy'; break; default: throw new \BadMethodCallException("Undefined method '{$method}'. The method name must start with " . "either findBy or findOneBy!"); } if (empty($arguments)) { throw \MailPoetVendor\Doctrine\ORM\ORMException::findByRequiresParameter($method . $by); } $fieldName = \lcfirst(\MailPoetVendor\Doctrine\Common\Util\Inflector::classify($by)); if ($this->_class->hasField($fieldName) || $this->_class->hasAssociation($fieldName)) { switch (\count($arguments)) { case 1: return $this->{$method}(array($fieldName => $arguments[0])); case 2: return $this->{$method}(array($fieldName => $arguments[0]), $arguments[1]); case 3: return $this->{$method}(array($fieldName => $arguments[0]), $arguments[1], $arguments[2]); case 4: return $this->{$method}(array($fieldName => $arguments[0]), $arguments[1], $arguments[2], $arguments[3]); default: } } throw \MailPoetVendor\Doctrine\ORM\ORMException::invalidFindByCall($this->_entityName, $fieldName, $method . $by); } protected function getEntityName() { return $this->_entityName; } public function getClassName() { return $this->getEntityName(); } protected function getEntityManager() { return $this->_em; } protected function getClassMetadata() { return $this->_class; } public function matching(\MailPoetVendor\Doctrine\Common\Collections\Criteria $criteria) { $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName); return new \MailPoetVendor\Doctrine\ORM\LazyCriteriaCollection($persister, $criteria); } } 
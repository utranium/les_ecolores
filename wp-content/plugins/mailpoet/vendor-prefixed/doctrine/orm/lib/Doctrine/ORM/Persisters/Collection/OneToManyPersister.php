<?php
 namespace MailPoetVendor\Doctrine\ORM\Persisters\Collection; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\Common\Collections\Criteria; use MailPoetVendor\Doctrine\Common\Proxy\Proxy; use MailPoetVendor\Doctrine\ORM\PersistentCollection; class OneToManyPersister extends \MailPoetVendor\Doctrine\ORM\Persisters\Collection\AbstractCollectionPersister { public function delete(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection) { return; } public function update(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection) { return; } public function get(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection, $index) { $mapping = $collection->getMapping(); if (!isset($mapping['indexBy'])) { throw new \BadMethodCallException("Selecting a collection by index is only supported on indexed collections."); } $persister = $this->uow->getEntityPersister($mapping['targetEntity']); return $persister->load(array($mapping['mappedBy'] => $collection->getOwner(), $mapping['indexBy'] => $index), null, $mapping, array(), null, 1); } public function count(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection) { $mapping = $collection->getMapping(); $persister = $this->uow->getEntityPersister($mapping['targetEntity']); $criteria = new \MailPoetVendor\Doctrine\Common\Collections\Criteria(\MailPoetVendor\Doctrine\Common\Collections\Criteria::expr()->eq($mapping['mappedBy'], $collection->getOwner())); return $persister->count($criteria); } public function slice(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection, $offset, $length = null) { $mapping = $collection->getMapping(); $persister = $this->uow->getEntityPersister($mapping['targetEntity']); return $persister->getOneToManyCollection($mapping, $collection->getOwner(), $offset, $length); } public function containsKey(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection, $key) { $mapping = $collection->getMapping(); if (!isset($mapping['indexBy'])) { throw new \BadMethodCallException("Selecting a collection by index is only supported on indexed collections."); } $persister = $this->uow->getEntityPersister($mapping['targetEntity']); $criteria = new \MailPoetVendor\Doctrine\Common\Collections\Criteria(); $criteria->andWhere(\MailPoetVendor\Doctrine\Common\Collections\Criteria::expr()->eq($mapping['mappedBy'], $collection->getOwner())); $criteria->andWhere(\MailPoetVendor\Doctrine\Common\Collections\Criteria::expr()->eq($mapping['indexBy'], $key)); return (bool) $persister->count($criteria); } public function contains(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection, $element) { if (!$this->isValidEntityState($element)) { return \false; } $mapping = $collection->getMapping(); $persister = $this->uow->getEntityPersister($mapping['targetEntity']); $criteria = new \MailPoetVendor\Doctrine\Common\Collections\Criteria(\MailPoetVendor\Doctrine\Common\Collections\Criteria::expr()->eq($mapping['mappedBy'], $collection->getOwner())); return $persister->exists($element, $criteria); } public function removeElement(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection, $element) { $mapping = $collection->getMapping(); if (!$mapping['orphanRemoval']) { return \false; } if (!$this->isValidEntityState($element)) { return \false; } return $this->uow->getEntityPersister($mapping['targetEntity'])->delete($element); } public function loadCriteria(\MailPoetVendor\Doctrine\ORM\PersistentCollection $collection, \MailPoetVendor\Doctrine\Common\Collections\Criteria $criteria) { throw new \BadMethodCallException("Filtering a collection by Criteria is not supported by this CollectionPersister."); } } 
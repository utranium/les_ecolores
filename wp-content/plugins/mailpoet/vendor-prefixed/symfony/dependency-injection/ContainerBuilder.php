<?php
 namespace MailPoetVendor\Symfony\Component\DependencyInjection; if (!defined('ABSPATH')) exit; use MailPoetVendor\Psr\Container\ContainerInterface as PsrContainerInterface; use MailPoetVendor\Symfony\Component\Config\Resource\ClassExistenceResource; use MailPoetVendor\Symfony\Component\Config\Resource\ComposerResource; use MailPoetVendor\Symfony\Component\Config\Resource\DirectoryResource; use MailPoetVendor\Symfony\Component\Config\Resource\FileExistenceResource; use MailPoetVendor\Symfony\Component\Config\Resource\FileResource; use MailPoetVendor\Symfony\Component\Config\Resource\GlobResource; use MailPoetVendor\Symfony\Component\Config\Resource\ReflectionClassResource; use MailPoetVendor\Symfony\Component\Config\Resource\ResourceInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\Argument\IteratorArgument; use MailPoetVendor\Symfony\Component\DependencyInjection\Argument\RewindableGenerator; use MailPoetVendor\Symfony\Component\DependencyInjection\Argument\ServiceClosureArgument; use MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\Compiler; use MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\PassConfig; use MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\ResolveEnvPlaceholdersPass; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\BadMethodCallException; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\LogicException; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\RuntimeException; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceCircularReferenceException; use MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException; use MailPoetVendor\Symfony\Component\DependencyInjection\Extension\ExtensionInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\LazyProxy\Instantiator\InstantiatorInterface; use MailPoetVendor\Symfony\Component\DependencyInjection\LazyProxy\Instantiator\RealServiceInstantiator; use MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag; use MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag; use MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface; use MailPoetVendor\Symfony\Component\EventDispatcher\ContainerAwareEventDispatcher; use MailPoetVendor\Symfony\Component\ExpressionLanguage\Expression; use MailPoetVendor\Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface; class ContainerBuilder extends \MailPoetVendor\Symfony\Component\DependencyInjection\Container implements \MailPoetVendor\Symfony\Component\DependencyInjection\TaggedContainerInterface { private $extensions = []; private $extensionsByNs = []; private $definitions = []; private $aliasDefinitions = []; private $resources = []; private $extensionConfigs = []; private $compiler; private $trackResources; private $proxyInstantiator; private $expressionLanguage; private $expressionLanguageProviders = []; private $usedTags = []; private $envPlaceholders = []; private $envCounters = []; private $vendors; private $autoconfiguredInstanceof = []; private $removedIds = []; private $removedBindingIds = []; private static $internalTypes = ['int' => \true, 'float' => \true, 'string' => \true, 'bool' => \true, 'resource' => \true, 'object' => \true, 'array' => \true, 'null' => \true, 'callable' => \true, 'iterable' => \true, 'mixed' => \true]; public function __construct(\MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface $parameterBag = null) { parent::__construct($parameterBag); $this->trackResources = \interface_exists('MailPoetVendor\\Symfony\\Component\\Config\\Resource\\ResourceInterface'); $this->setDefinition('service_container', (new \MailPoetVendor\Symfony\Component\DependencyInjection\Definition(\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::class))->setSynthetic(\true)->setPublic(\true)); $this->setAlias(\MailPoetVendor\Psr\Container\ContainerInterface::class, new \MailPoetVendor\Symfony\Component\DependencyInjection\Alias('service_container', \false)); $this->setAlias(\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::class, new \MailPoetVendor\Symfony\Component\DependencyInjection\Alias('service_container', \false)); } private $classReflectors; public function setResourceTracking($track) { $this->trackResources = (bool) $track; } public function isTrackingResources() { return $this->trackResources; } public function setProxyInstantiator(\MailPoetVendor\Symfony\Component\DependencyInjection\LazyProxy\Instantiator\InstantiatorInterface $proxyInstantiator) { $this->proxyInstantiator = $proxyInstantiator; } public function registerExtension(\MailPoetVendor\Symfony\Component\DependencyInjection\Extension\ExtensionInterface $extension) { $this->extensions[$extension->getAlias()] = $extension; if (\false !== $extension->getNamespace()) { $this->extensionsByNs[$extension->getNamespace()] = $extension; } } public function getExtension($name) { if (isset($this->extensions[$name])) { return $this->extensions[$name]; } if (isset($this->extensionsByNs[$name])) { return $this->extensionsByNs[$name]; } throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\LogicException(\sprintf('Container extension "%s" is not registered', $name)); } public function getExtensions() { return $this->extensions; } public function hasExtension($name) { return isset($this->extensions[$name]) || isset($this->extensionsByNs[$name]); } public function getResources() { return \array_values($this->resources); } public function addResource(\MailPoetVendor\Symfony\Component\Config\Resource\ResourceInterface $resource) { if (!$this->trackResources) { return $this; } if ($resource instanceof \MailPoetVendor\Symfony\Component\Config\Resource\GlobResource && $this->inVendors($resource->getPrefix())) { return $this; } $this->resources[(string) $resource] = $resource; return $this; } public function setResources(array $resources) { if (!$this->trackResources) { return $this; } $this->resources = $resources; return $this; } public function addObjectResource($object) { if ($this->trackResources) { if (\is_object($object)) { $object = \get_class($object); } if (!isset($this->classReflectors[$object])) { $this->classReflectors[$object] = new \ReflectionClass($object); } $class = $this->classReflectors[$object]; foreach ($class->getInterfaceNames() as $name) { if (null === ($interface =& $this->classReflectors[$name])) { $interface = new \ReflectionClass($name); } $file = $interface->getFileName(); if (\false !== $file && \file_exists($file)) { $this->fileExists($file); } } do { $file = $class->getFileName(); if (\false !== $file && \file_exists($file)) { $this->fileExists($file); } foreach ($class->getTraitNames() as $name) { $this->addObjectResource($name); } } while ($class = $class->getParentClass()); } return $this; } public function addClassResource(\ReflectionClass $class) { @\trigger_error('The ' . __METHOD__ . '() method is deprecated since Symfony 3.3 and will be removed in 4.0. Use the addObjectResource() or the getReflectionClass() method instead.', \E_USER_DEPRECATED); return $this->addObjectResource($class->name); } public function getReflectionClass($class, $throw = \true) { if (!($class = $this->getParameterBag()->resolveValue($class))) { return null; } if (isset(self::$internalTypes[$class])) { return null; } $resource = $classReflector = null; try { if (isset($this->classReflectors[$class])) { $classReflector = $this->classReflectors[$class]; } elseif (\class_exists(\MailPoetVendor\Symfony\Component\Config\Resource\ClassExistenceResource::class)) { $resource = new \MailPoetVendor\Symfony\Component\Config\Resource\ClassExistenceResource($class, \false); $classReflector = $resource->isFresh(0) ? \false : new \ReflectionClass($class); } else { $classReflector = \class_exists($class) ? new \ReflectionClass($class) : \false; } } catch (\ReflectionException $e) { if ($throw) { throw $e; } } if ($this->trackResources) { if (!$classReflector) { $this->addResource($resource ?: new \MailPoetVendor\Symfony\Component\Config\Resource\ClassExistenceResource($class, \false)); } elseif (!$classReflector->isInternal()) { $path = $classReflector->getFileName(); if (!$this->inVendors($path)) { $this->addResource(new \MailPoetVendor\Symfony\Component\Config\Resource\ReflectionClassResource($classReflector, $this->vendors)); } } $this->classReflectors[$class] = $classReflector; } return $classReflector ?: null; } public function fileExists($path, $trackContents = \true) { $exists = \file_exists($path); if (!$this->trackResources || $this->inVendors($path)) { return $exists; } if (!$exists) { $this->addResource(new \MailPoetVendor\Symfony\Component\Config\Resource\FileExistenceResource($path)); return $exists; } if (\is_dir($path)) { if ($trackContents) { $this->addResource(new \MailPoetVendor\Symfony\Component\Config\Resource\DirectoryResource($path, \is_string($trackContents) ? $trackContents : null)); } else { $this->addResource(new \MailPoetVendor\Symfony\Component\Config\Resource\GlobResource($path, '/*', \false)); } } elseif ($trackContents) { $this->addResource(new \MailPoetVendor\Symfony\Component\Config\Resource\FileResource($path)); } return $exists; } public function loadFromExtension($extension, array $values = null) { if ($this->isCompiled()) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\BadMethodCallException('Cannot load from an extension on a compiled container.'); } if (\func_num_args() < 2) { $values = []; } $namespace = $this->getExtension($extension)->getAlias(); $this->extensionConfigs[$namespace][] = $values; return $this; } public function addCompilerPass(\MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface $pass, $type = \MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\PassConfig::TYPE_BEFORE_OPTIMIZATION) { if (\func_num_args() >= 3) { $priority = \func_get_arg(2); } else { if (__CLASS__ !== \get_class($this)) { $r = new \ReflectionMethod($this, __FUNCTION__); if (__CLASS__ !== $r->getDeclaringClass()->getName()) { @\trigger_error(\sprintf('Method %s() will have a third `int $priority = 0` argument in version 4.0. Not defining it is deprecated since Symfony 3.2.', __METHOD__), \E_USER_DEPRECATED); } } $priority = 0; } $this->getCompiler()->addPass($pass, $type, $priority); $this->addObjectResource($pass); return $this; } public function getCompilerPassConfig() { return $this->getCompiler()->getPassConfig(); } public function getCompiler() { if (null === $this->compiler) { $this->compiler = new \MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\Compiler(); } return $this->compiler; } public function set($id, $service) { $id = $this->normalizeId($id); if ($this->isCompiled() && (isset($this->definitions[$id]) && !$this->definitions[$id]->isSynthetic())) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\BadMethodCallException(\sprintf('Setting service "%s" for an unknown or non-synthetic service definition on a compiled container is not allowed.', $id)); } unset($this->definitions[$id], $this->aliasDefinitions[$id], $this->removedIds[$id]); parent::set($id, $service); } public function removeDefinition($id) { if (isset($this->definitions[$id = $this->normalizeId($id)])) { unset($this->definitions[$id]); $this->removedIds[$id] = \true; } } public function has($id) { $id = $this->normalizeId($id); return isset($this->definitions[$id]) || isset($this->aliasDefinitions[$id]) || parent::has($id); } public function get($id, $invalidBehavior = \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE) { if ($this->isCompiled() && isset($this->removedIds[$id = $this->normalizeId($id)])) { @\trigger_error(\sprintf('Fetching the "%s" private service or alias is deprecated since Symfony 3.4 and will fail in 4.0. Make it public instead.', $id), \E_USER_DEPRECATED); } return $this->doGet($id, $invalidBehavior); } private function doGet($id, $invalidBehavior = \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE, array &$inlineServices = null, $isConstructorArgument = \false) { $id = $this->normalizeId($id); if (isset($inlineServices[$id])) { return $inlineServices[$id]; } if (null === $inlineServices) { $isConstructorArgument = \true; $inlineServices = []; } try { if (\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE === $invalidBehavior) { return parent::get($id, $invalidBehavior); } if ($service = parent::get($id, \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::NULL_ON_INVALID_REFERENCE)) { return $service; } } catch (\MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceCircularReferenceException $e) { if ($isConstructorArgument) { throw $e; } } if (!isset($this->definitions[$id]) && isset($this->aliasDefinitions[$id])) { return $this->doGet((string) $this->aliasDefinitions[$id], $invalidBehavior, $inlineServices, $isConstructorArgument); } try { $definition = $this->getDefinition($id); } catch (\MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException $e) { if (\MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE !== $invalidBehavior) { return null; } throw $e; } if ($isConstructorArgument) { $this->loading[$id] = \true; } try { return $this->createService($definition, $inlineServices, $isConstructorArgument, $id); } finally { if ($isConstructorArgument) { unset($this->loading[$id]); } } } public function merge(self $container) { if ($this->isCompiled()) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\BadMethodCallException('Cannot merge on a compiled container.'); } $this->addDefinitions($container->getDefinitions()); $this->addAliases($container->getAliases()); $this->getParameterBag()->add($container->getParameterBag()->all()); if ($this->trackResources) { foreach ($container->getResources() as $resource) { $this->addResource($resource); } } foreach ($this->extensions as $name => $extension) { if (!isset($this->extensionConfigs[$name])) { $this->extensionConfigs[$name] = []; } $this->extensionConfigs[$name] = \array_merge($this->extensionConfigs[$name], $container->getExtensionConfig($name)); } if ($this->getParameterBag() instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag && $container->getParameterBag() instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag) { $envPlaceholders = $container->getParameterBag()->getEnvPlaceholders(); $this->getParameterBag()->mergeEnvPlaceholders($container->getParameterBag()); } else { $envPlaceholders = []; } foreach ($container->envCounters as $env => $count) { if (!$count && !isset($envPlaceholders[$env])) { continue; } if (!isset($this->envCounters[$env])) { $this->envCounters[$env] = $count; } else { $this->envCounters[$env] += $count; } } foreach ($container->getAutoconfiguredInstanceof() as $interface => $childDefinition) { if (isset($this->autoconfiguredInstanceof[$interface])) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('"%s" has already been autoconfigured and merge() does not support merging autoconfiguration for the same class/interface.', $interface)); } $this->autoconfiguredInstanceof[$interface] = $childDefinition; } } public function getExtensionConfig($name) { if (!isset($this->extensionConfigs[$name])) { $this->extensionConfigs[$name] = []; } return $this->extensionConfigs[$name]; } public function prependExtensionConfig($name, array $config) { if (!isset($this->extensionConfigs[$name])) { $this->extensionConfigs[$name] = []; } \array_unshift($this->extensionConfigs[$name], $config); } public function compile() { if (1 <= \func_num_args()) { $resolveEnvPlaceholders = \func_get_arg(0); } else { if (__CLASS__ !== static::class) { $r = new \ReflectionMethod($this, __FUNCTION__); if (__CLASS__ !== $r->getDeclaringClass()->getName() && (1 > $r->getNumberOfParameters() || 'resolveEnvPlaceholders' !== $r->getParameters()[0]->name)) { @\trigger_error(\sprintf('The %s::compile() method expects a first "$resolveEnvPlaceholders" argument since Symfony 3.3. It will be made mandatory in 4.0.', static::class), \E_USER_DEPRECATED); } } $resolveEnvPlaceholders = \false; } $compiler = $this->getCompiler(); if ($this->trackResources) { foreach ($compiler->getPassConfig()->getPasses() as $pass) { $this->addObjectResource($pass); } } $bag = $this->getParameterBag(); if ($resolveEnvPlaceholders && $bag instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag) { $compiler->addPass(new \MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\ResolveEnvPlaceholdersPass(), \MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\PassConfig::TYPE_AFTER_REMOVING, -1000); } $compiler->compile($this); foreach ($this->definitions as $id => $definition) { if ($this->trackResources && $definition->isLazy()) { $this->getReflectionClass($definition->getClass()); } } $this->extensionConfigs = []; if ($bag instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag) { if ($resolveEnvPlaceholders) { $this->parameterBag = new \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag($this->resolveEnvPlaceholders($bag->all(), \true)); } $this->envPlaceholders = $bag->getEnvPlaceholders(); } parent::compile(); foreach ($this->definitions + $this->aliasDefinitions as $id => $definition) { if (!$definition->isPublic() || $definition->isPrivate()) { $this->removedIds[$id] = \true; } } } public function getServiceIds() { return \array_map('strval', \array_unique(\array_merge(\array_keys($this->getDefinitions()), \array_keys($this->aliasDefinitions), parent::getServiceIds()))); } public function getRemovedIds() { return $this->removedIds; } public function addAliases(array $aliases) { foreach ($aliases as $alias => $id) { $this->setAlias($alias, $id); } } public function setAliases(array $aliases) { $this->aliasDefinitions = []; $this->addAliases($aliases); } public function setAlias($alias, $id) { $alias = $this->normalizeId($alias); if ('' === $alias || '\\' === \substr($alias, -1) || \strlen($alias) !== \strcspn($alias, "\0\r\n'")) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('Invalid alias id: "%s"', $alias)); } if (\is_string($id)) { $id = new \MailPoetVendor\Symfony\Component\DependencyInjection\Alias($this->normalizeId($id)); } elseif (!$id instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Alias) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException('$id must be a string, or an Alias object.'); } if ($alias === (string) $id) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('An alias can not reference itself, got a circular reference on "%s".', $alias)); } unset($this->definitions[$alias], $this->removedIds[$alias]); return $this->aliasDefinitions[$alias] = $id; } public function removeAlias($alias) { if (isset($this->aliasDefinitions[$alias = $this->normalizeId($alias)])) { unset($this->aliasDefinitions[$alias]); $this->removedIds[$alias] = \true; } } public function hasAlias($id) { return isset($this->aliasDefinitions[$this->normalizeId($id)]); } public function getAliases() { return $this->aliasDefinitions; } public function getAlias($id) { $id = $this->normalizeId($id); if (!isset($this->aliasDefinitions[$id])) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('The service alias "%s" does not exist.', $id)); } return $this->aliasDefinitions[$id]; } public function register($id, $class = null) { return $this->setDefinition($id, new \MailPoetVendor\Symfony\Component\DependencyInjection\Definition($class)); } public function autowire($id, $class = null) { return $this->setDefinition($id, (new \MailPoetVendor\Symfony\Component\DependencyInjection\Definition($class))->setAutowired(\true)); } public function addDefinitions(array $definitions) { foreach ($definitions as $id => $definition) { $this->setDefinition($id, $definition); } } public function setDefinitions(array $definitions) { $this->definitions = []; $this->addDefinitions($definitions); } public function getDefinitions() { return $this->definitions; } public function setDefinition($id, \MailPoetVendor\Symfony\Component\DependencyInjection\Definition $definition) { if ($this->isCompiled()) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\BadMethodCallException('Adding definition to a compiled container is not allowed'); } $id = $this->normalizeId($id); if ('' === $id || '\\' === \substr($id, -1) || \strlen($id) !== \strcspn($id, "\0\r\n'")) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('Invalid service id: "%s"', $id)); } unset($this->aliasDefinitions[$id], $this->removedIds[$id]); return $this->definitions[$id] = $definition; } public function hasDefinition($id) { return isset($this->definitions[$this->normalizeId($id)]); } public function getDefinition($id) { $id = $this->normalizeId($id); if (!isset($this->definitions[$id])) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException($id); } return $this->definitions[$id]; } public function findDefinition($id) { $id = $this->normalizeId($id); $seen = []; while (isset($this->aliasDefinitions[$id])) { $id = (string) $this->aliasDefinitions[$id]; if (isset($seen[$id])) { $seen = \array_values($seen); $seen = \array_slice($seen, \array_search($id, $seen)); $seen[] = $id; throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\ServiceCircularReferenceException($id, $seen); } $seen[$id] = $id; } return $this->getDefinition($id); } private function createService(\MailPoetVendor\Symfony\Component\DependencyInjection\Definition $definition, array &$inlineServices, $isConstructorArgument = \false, $id = null, $tryProxy = \true) { if (null === $id && isset($inlineServices[$h = \spl_object_hash($definition)])) { return $inlineServices[$h]; } if ($definition instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ChildDefinition) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\RuntimeException(\sprintf('Constructing service "%s" from a parent definition is not supported at build time.', $id)); } if ($definition->isSynthetic()) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\RuntimeException(\sprintf('You have requested a synthetic service ("%s"). The DIC does not know how to construct this service.', $id)); } if ($definition->isDeprecated()) { @\trigger_error($definition->getDeprecationMessage($id), \E_USER_DEPRECATED); } if ($tryProxy && $definition->isLazy() && !($tryProxy = !($proxy = $this->proxyInstantiator) || $proxy instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\LazyProxy\Instantiator\RealServiceInstantiator)) { $proxy = $proxy->instantiateProxy($this, $definition, $id, function () use($definition, &$inlineServices, $id) { return $this->createService($definition, $inlineServices, \true, $id, \false); }); $this->shareService($definition, $proxy, $id, $inlineServices); return $proxy; } $parameterBag = $this->getParameterBag(); if (null !== $definition->getFile()) { require_once $parameterBag->resolveValue($definition->getFile()); } $arguments = $this->doResolveServices($parameterBag->unescapeValue($parameterBag->resolveValue($definition->getArguments())), $inlineServices, $isConstructorArgument); if (null !== ($factory = $definition->getFactory())) { if (\is_array($factory)) { $factory = [$this->doResolveServices($parameterBag->resolveValue($factory[0]), $inlineServices, $isConstructorArgument), $factory[1]]; } elseif (!\is_string($factory)) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\RuntimeException(\sprintf('Cannot create service "%s" because of invalid factory', $id)); } } if (null !== $id && $definition->isShared() && isset($this->services[$id]) && ($tryProxy || !$definition->isLazy())) { return $this->services[$id]; } if (null !== $factory) { $service = \call_user_func_array($factory, $arguments); if (!$definition->isDeprecated() && \is_array($factory) && \is_string($factory[0])) { $r = new \ReflectionClass($factory[0]); if (0 < \strpos($r->getDocComment(), "\n * @deprecated ")) { @\trigger_error(\sprintf('The "%s" service relies on the deprecated "%s" factory class. It should either be deprecated or its factory upgraded.', $id, $r->name), \E_USER_DEPRECATED); } } } else { $r = new \ReflectionClass($class = $parameterBag->resolveValue($definition->getClass())); $service = null === $r->getConstructor() ? $r->newInstance() : $r->newInstanceArgs($arguments); $deprecationWhitelist = ['event_dispatcher' => \MailPoetVendor\Symfony\Component\EventDispatcher\ContainerAwareEventDispatcher::class]; if (!$definition->isDeprecated() && 0 < \strpos($r->getDocComment(), "\n * @deprecated ") && (!isset($deprecationWhitelist[$id]) || $deprecationWhitelist[$id] !== $class)) { @\trigger_error(\sprintf('The "%s" service relies on the deprecated "%s" class. It should either be deprecated or its implementation upgraded.', $id, $r->name), \E_USER_DEPRECATED); } } if ($tryProxy || !$definition->isLazy()) { $this->shareService($definition, $service, $id, $inlineServices); } $properties = $this->doResolveServices($parameterBag->unescapeValue($parameterBag->resolveValue($definition->getProperties())), $inlineServices); foreach ($properties as $name => $value) { $service->{$name} = $value; } foreach ($definition->getMethodCalls() as $call) { $this->callMethod($service, $call, $inlineServices); } if ($callable = $definition->getConfigurator()) { if (\is_array($callable)) { $callable[0] = $parameterBag->resolveValue($callable[0]); if ($callable[0] instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Reference) { $callable[0] = $this->doGet((string) $callable[0], $callable[0]->getInvalidBehavior(), $inlineServices); } elseif ($callable[0] instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Definition) { $callable[0] = $this->createService($callable[0], $inlineServices); } } if (!\is_callable($callable)) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('The configure callable for class "%s" is not a callable.', \get_class($service))); } \call_user_func($callable, $service); } return $service; } public function resolveServices($value) { return $this->doResolveServices($value); } private function doResolveServices($value, array &$inlineServices = [], $isConstructorArgument = \false) { if (\is_array($value)) { foreach ($value as $k => $v) { $value[$k] = $this->doResolveServices($v, $inlineServices, $isConstructorArgument); } } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Argument\ServiceClosureArgument) { $reference = $value->getValues()[0]; $value = function () use($reference) { return $this->resolveServices($reference); }; } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Argument\IteratorArgument) { $value = new \MailPoetVendor\Symfony\Component\DependencyInjection\Argument\RewindableGenerator(function () use($value) { foreach ($value->getValues() as $k => $v) { foreach (self::getServiceConditionals($v) as $s) { if (!$this->has($s)) { continue 2; } } foreach (self::getInitializedConditionals($v) as $s) { if (!$this->doGet($s, \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE)) { continue 2; } } (yield $k => $this->resolveServices($v)); } }, function () use($value) { $count = 0; foreach ($value->getValues() as $v) { foreach (self::getServiceConditionals($v) as $s) { if (!$this->has($s)) { continue 2; } } foreach (self::getInitializedConditionals($v) as $s) { if (!$this->doGet($s, \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE)) { continue 2; } } ++$count; } return $count; }); } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Reference) { $value = $this->doGet((string) $value, $value->getInvalidBehavior(), $inlineServices, $isConstructorArgument); } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Definition) { $value = $this->createService($value, $inlineServices, $isConstructorArgument); } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Parameter) { $value = $this->getParameter((string) $value); } elseif ($value instanceof \MailPoetVendor\Symfony\Component\ExpressionLanguage\Expression) { $value = $this->getExpressionLanguage()->evaluate($value, ['container' => $this]); } return $value; } public function findTaggedServiceIds($name, $throwOnAbstract = \false) { $this->usedTags[] = $name; $tags = []; foreach ($this->getDefinitions() as $id => $definition) { if ($definition->hasTag($name)) { if ($throwOnAbstract && $definition->isAbstract()) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\InvalidArgumentException(\sprintf('The service "%s" tagged "%s" must not be abstract.', $id, $name)); } $tags[$id] = $definition->getTag($name); } } return $tags; } public function findTags() { $tags = []; foreach ($this->getDefinitions() as $id => $definition) { $tags = \array_merge(\array_keys($definition->getTags()), $tags); } return \array_unique($tags); } public function findUnusedTags() { return \array_values(\array_diff($this->findTags(), $this->usedTags)); } public function addExpressionLanguageProvider(\MailPoetVendor\Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface $provider) { $this->expressionLanguageProviders[] = $provider; } public function getExpressionLanguageProviders() { return $this->expressionLanguageProviders; } public function registerForAutoconfiguration($interface) { if (!isset($this->autoconfiguredInstanceof[$interface])) { $this->autoconfiguredInstanceof[$interface] = new \MailPoetVendor\Symfony\Component\DependencyInjection\ChildDefinition(''); } return $this->autoconfiguredInstanceof[$interface]; } public function getAutoconfiguredInstanceof() { return $this->autoconfiguredInstanceof; } public function resolveEnvPlaceholders($value, $format = null, array &$usedEnvs = null) { if (null === $format) { $format = '%%env(%s)%%'; } $bag = $this->getParameterBag(); if (\true === $format) { $value = $bag->resolveValue($value); } if (\is_array($value)) { $result = []; foreach ($value as $k => $v) { $result[\is_string($k) ? $this->resolveEnvPlaceholders($k, $format, $usedEnvs) : $k] = $this->resolveEnvPlaceholders($v, $format, $usedEnvs); } return $result; } if (!\is_string($value) || 38 > \strlen($value)) { return $value; } $envPlaceholders = $bag instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag ? $bag->getEnvPlaceholders() : $this->envPlaceholders; $completed = \false; foreach ($envPlaceholders as $env => $placeholders) { foreach ($placeholders as $placeholder) { if (\false !== \stripos($value, $placeholder)) { if (\true === $format) { $resolved = $bag->escapeValue($this->getEnv($env)); } else { $resolved = \sprintf($format, $env); } if ($placeholder === $value) { $value = $resolved; $completed = \true; } else { if (!\is_string($resolved) && !\is_numeric($resolved)) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\RuntimeException(\sprintf('A string value must be composed of strings and/or numbers, but found parameter "env(%s)" of type %s inside string value "%s".', $env, \gettype($resolved), $this->resolveEnvPlaceholders($value))); } $value = \str_ireplace($placeholder, $resolved, $value); } $usedEnvs[$env] = $env; $this->envCounters[$env] = isset($this->envCounters[$env]) ? 1 + $this->envCounters[$env] : 1; if ($completed) { break 2; } } } } return $value; } public function getEnvCounters() { $bag = $this->getParameterBag(); $envPlaceholders = $bag instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag ? $bag->getEnvPlaceholders() : $this->envPlaceholders; foreach ($envPlaceholders as $env => $placeholders) { if (!isset($this->envCounters[$env])) { $this->envCounters[$env] = 0; } } return $this->envCounters; } public function getNormalizedIds() { $normalizedIds = []; foreach ($this->normalizedIds as $k => $v) { if ($v !== (string) $k) { $normalizedIds[$k] = $v; } } return $normalizedIds; } public function log(\MailPoetVendor\Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface $pass, $message) { $this->getCompiler()->log($pass, $this->resolveEnvPlaceholders($message)); } public function normalizeId($id) { if (!\is_string($id)) { $id = (string) $id; } return isset($this->definitions[$id]) || isset($this->aliasDefinitions[$id]) || isset($this->removedIds[$id]) ? $id : parent::normalizeId($id); } public function getRemovedBindingIds() { return $this->removedBindingIds; } public function removeBindings($id) { if ($this->hasDefinition($id)) { foreach ($this->getDefinition($id)->getBindings() as $key => $binding) { list(, $bindingId) = $binding->getValues(); $this->removedBindingIds[(int) $bindingId] = \true; } } } public static function getServiceConditionals($value) { $services = []; if (\is_array($value)) { foreach ($value as $v) { $services = \array_unique(\array_merge($services, self::getServiceConditionals($v))); } } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Reference && \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_INVALID_REFERENCE === $value->getInvalidBehavior()) { $services[] = (string) $value; } return $services; } public static function getInitializedConditionals($value) { $services = []; if (\is_array($value)) { foreach ($value as $v) { $services = \array_unique(\array_merge($services, self::getInitializedConditionals($v))); } } elseif ($value instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\Reference && \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE === $value->getInvalidBehavior()) { $services[] = (string) $value; } return $services; } public static function hash($value) { $hash = \substr(\base64_encode(\hash('sha256', \serialize($value), \true)), 0, 7); return \str_replace(['/', '+'], ['.', '_'], \strtolower($hash)); } protected function getEnv($name) { $value = parent::getEnv($name); $bag = $this->getParameterBag(); if (!\is_string($value) || !$bag instanceof \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\EnvPlaceholderParameterBag) { return $value; } foreach ($bag->getEnvPlaceholders() as $env => $placeholders) { if (isset($placeholders[$value])) { $bag = new \MailPoetVendor\Symfony\Component\DependencyInjection\ParameterBag\ParameterBag($bag->all()); return $bag->unescapeValue($bag->get("env({$name})")); } } $this->resolving["env({$name})"] = \true; try { return $bag->unescapeValue($this->resolveEnvPlaceholders($bag->escapeValue($value), \true)); } finally { unset($this->resolving["env({$name})"]); } } private function callMethod($service, $call, array &$inlineServices) { foreach (self::getServiceConditionals($call[1]) as $s) { if (!$this->has($s)) { return; } } foreach (self::getInitializedConditionals($call[1]) as $s) { if (!$this->doGet($s, \MailPoetVendor\Symfony\Component\DependencyInjection\ContainerInterface::IGNORE_ON_UNINITIALIZED_REFERENCE, $inlineServices)) { return; } } \call_user_func_array([$service, $call[0]], $this->doResolveServices($this->getParameterBag()->unescapeValue($this->getParameterBag()->resolveValue($call[1])), $inlineServices)); } private function shareService(\MailPoetVendor\Symfony\Component\DependencyInjection\Definition $definition, $service, $id, array &$inlineServices) { $inlineServices[null !== $id ? $id : \spl_object_hash($definition)] = $service; if (null !== $id && $definition->isShared()) { $this->services[$id] = $service; unset($this->loading[$id]); } } private function getExpressionLanguage() { if (null === $this->expressionLanguage) { if (!\class_exists('MailPoetVendor\\Symfony\\Component\\ExpressionLanguage\\ExpressionLanguage')) { throw new \MailPoetVendor\Symfony\Component\DependencyInjection\Exception\RuntimeException('Unable to use expressions as the Symfony ExpressionLanguage component is not installed.'); } $this->expressionLanguage = new \MailPoetVendor\Symfony\Component\DependencyInjection\ExpressionLanguage(null, $this->expressionLanguageProviders); } return $this->expressionLanguage; } private function inVendors($path) { if (null === $this->vendors) { $resource = new \MailPoetVendor\Symfony\Component\Config\Resource\ComposerResource(); $this->vendors = $resource->getVendors(); $this->addResource($resource); } $path = \realpath($path) ?: $path; foreach ($this->vendors as $vendor) { if (0 === \strpos($path, $vendor) && \false !== \strpbrk(\substr($path, \strlen($vendor), 1), '/' . \DIRECTORY_SEPARATOR)) { return \true; } } return \false; } } 